% !TEX encoding = IsoLatin
% --------------------------------------------------------------------------------------------------------------------------------------------------------------------------- %
%\begin{itemize}
%\item [-] \textbf{Création} : Demandée par un autre processus,  crée dans l'état prêt ou suspendu.
%\item [-] \textbf{Destruction} : peut être fait par le processus lui-même, un autre processus, le noyau. La destruction provoque une libération des ressources associées et un évènement.
%\item [-] \textbf{Blocage} : passage en mode bloqué en attente d'un évènement externe. Peut être demandé par le processus lui-même ou par le système.
%\item [-] \textbf{Déblocage} : passage en mode prêt après le mode bloqué lorsque l'événement attendu se produit.
%\item [-] \textbf{Activation} : passage en mode exécution d'un mode prêt.
%\end{itemize}

  
%\begin{Verbatim}[frame=single,fontsize=\scriptsize]
%\end{Verbatim}

%\begin{figure}[h]
%	\begin{center}
%		\includegraphics[width=14.5cm,height=9cm]{.\figures\diag_etat_threads.png}
%	\end{center}
%	\caption{Diagramme des différents états d'un thread avec les primitives}
%	\label{fig:diag_etat_threads}
%\end{figure}

%% Modele d'etat avec les matrices

%\begin{displaymath}
%\left\{ \begin{array}{l} \dot{x} \quad = \quad \left[ \begin{array}{cccc}
%0 & 1 & 0 & 1\\
%- \frac{K_s}{M_s} & - \frac{C_s}{M_s} & 0 & \frac{C_s}{M_s}\\
%0 & 0 & 0 & 1\\
%\frac{K_s}{M_u} & \frac{C_s}{M_u} & - \frac{K_t}{M_u} & - \frac{C_s}{M_u} - \frac{C_t}{M_u}
%
%\end{array}\right]  x \quad + \quad \left[ \begin{array}{cc}
%0 & 1.1972\\
%0 & - 0.0012\\
%0 & 0\\
%7.84 & - 4.05
%\end{array} \right] u\\ \\
%y \quad = \quad \left[ \begin{array}{cccc}
%1 & 0 & 0 & 0\\
%0 & \lambda & 0 & 0\\
%0 & 0 & \lambda & 0\\
%0 & 0 & 0 & \lambda\\
%0 & - \lambda & \lambda & 0
%\end{array} \right] x \quad + \quad \left[ \begin{array}{cc}
%0 & 0\\
%0 & 0\\
%0 & 0\\
%0 & 0\\
%0 & 0
%\end{array} \right] u \end{array}\right.
%\end{displaymath}\\

% --------------------------------------------------------------------------------------------------------------------------------------------------------------------------- %
\rhead{\footnotesize\rightmark}
\chapter{Commande robuste}

\textcolor{red}{Maffre}

	Un retour d'état $K$ stabilisant le système et rejetant, au mieux, les perturbations (couple résistant $C_{charge}$) ayant été calculé pour le point de fonctionnement ($X_0$, $U_0$) considéré, il est maintenant nécessaire de vérifier la stabilité du système bouclé pour des points de fonctionnement différents. En effet, le point d'équilibre peut être en réalité légèrement différent ce celui calculé dans le chapitre 2. \\
	
	Nous utiliserons pour cela des méthodes de calcul \textit{LMI} (Linear Matrix Inequalities) (toolbox \texttt{lmi} de Matlab).


	\section{Calcul du retour d'état $K_{lmi}$ stabilisant}
	
		Nous allons tout d'abord recalculer un gain de retour d'état stabilisant le système (noté $K_{lmi}$). Cet exercice est bien entendu redondant par rapport à la partie précédente mais il permet d'introduire les \textit{LMI}. \\
		
		La théorie des \textit{LMI} que l'existence d'une matrice symétrique $P$ satisfaisant la théorie de Lyapunov est une condition nécessaire et suffisante de stabilité pouvant être décrite par l'équation : 
		
		\begin{align}
			PA^T + AP & < 0 \\
			P & > 0 
		\end{align}
		
		La matrice dynamique $A$ d'un système bouclé avec un gain de retour d'état $u = -Kx$ étant égale à $A_{bouclé} = (A - BK)$, on aura alors la \textit{LMI} suivante comme condition nécessaire et suffisante de stabilité : 
		
		\begin{align}
			P(A-BK)^T + (A+BK)P & < 0 \\
			P & > 0 
		\end{align}
		
		Cette \textit{LMI} étant non-linéaire, il est nécessaire d'effectuer le changement de variable $K = LP^{-1}$ pour assurer sa linéarité.
		
		\begin{align}
			PA^T + AP + L^TB + BL & < 0  \\
			P & > 0 
		\end{align}
		
		La matrice $K_{lmi}$ retournée par le script Matlab est alors telle que : 
		
		\begin{equation}
			K_{lmi} = [1.0042   -4.0059   -2.3667   -1.9401]
		\end{equation}
		
		Et permet d'assurer la stabilité du système en plaçant les pôles dans le demi-plan gauche du plan complexe. Cependant, comme aucune autre spécification sur le placement des pôles n'est donnée, le solveur \textit{LMI} se contente de trouver un seul gain qui stabilise le système. Autrement dit, la dernière itération correspond à l'itération à laquelle le solveur a trouvé pour la première fois un gain stabilisant. \\ 
		
		L'objectif est maintenant de spécifier des régions \textit{LMI} (à l'aide par exemple de la commande \texttt{lmireg})pour que les pôles en boucle fermée appartiennent à l'intersection de ces régions. Ces régions correspondent à : 
		
		\begin{itemize}
			\item Un demi-plan dont la partie réelle est inférieure à une valeur négative $x_0$ donnée, spécifiant alors le \textbf{temps de réponse du système}.
			\item Un demi-plan dont la partie réelle est supérieure à une valeur négative $x_1$ (telle que $x_1 < x_0$) donnée, pour \textbf{rester dans la bande passante} du système.
			\item Un secteur conique dont la pointe est située à l'origine du plan complexe, pour fixer l'amortissement et donc \textbf{limiter le dépassement}.
		\end{itemize}
		
		
		
		
		
		
		
		
	
	
	
	\section{Vérification de la stabilité du système}
