% !TEX encoding = IsoLatin
% --------------------------------------------------------------------------------------------------------------------------------------------------------------------------- %
%\begin{itemize}
%\item [-] \textbf{Création} : Demandée par un autre processus,  crée dans l'état prêt ou suspendu.
%\item [-] \textbf{Destruction} : peut être fait par le processus lui-même, un autre processus, le noyau. La destruction provoque une libération des ressources associées et un évènement.
%\item [-] \textbf{Blocage} : passage en mode bloqué en attente d'un évènement externe. Peut être demandé par le processus lui-même ou par le système.
%\item [-] \textbf{Déblocage} : passage en mode prêt après le mode bloqué lorsque l'événement attendu se produit.
%\item [-] \textbf{Activation} : passage en mode exécution d'un mode prêt.
%\end{itemize}

  
%\begin{Verbatim}[frame=single,fontsize=\scriptsize]
%\end{Verbatim}

%\begin{figure}[h]
%	\begin{center}
%		\includegraphics[width=14.5cm,height=9cm]{.\figures\diag_etat_threads.png}
%	\end{center}
%	\caption{Diagramme des différents états d'un thread avec les primitives}
%	\label{fig:diag_etat_threads}
%\end{figure}

%% Modele d'etat avec les matrices

%\begin{displaymath}
%\left\{ \begin{array}{l} \dot{x} \quad = \quad \left[ \begin{array}{cccc}
%0 & 1 & 0 & 1\\
%- \frac{K_s}{M_s} & - \frac{C_s}{M_s} & 0 & \frac{C_s}{M_s}\\
%0 & 0 & 0 & 1\\
%\frac{K_s}{M_u} & \frac{C_s}{M_u} & - \frac{K_t}{M_u} & - \frac{C_s}{M_u} - \frac{C_t}{M_u}
%
%\end{array}\right]  x \quad + \quad \left[ \begin{array}{cc}
%0 & 1.1972\\
%0 & - 0.0012\\
%0 & 0\\
%7.84 & - 4.05
%\end{array} \right] u\\ \\
%y \quad = \quad \left[ \begin{array}{cccc}
%1 & 0 & 0 & 0\\
%0 & \lambda & 0 & 0\\
%0 & 0 & \lambda & 0\\
%0 & 0 & 0 & \lambda\\
%0 & - \lambda & \lambda & 0
%\end{array} \right] x \quad + \quad \left[ \begin{array}{cc}
%0 & 0\\
%0 & 0\\
%0 & 0\\
%0 & 0\\
%0 & 0
%\end{array} \right] u \end{array}\right.
%\end{displaymath}\\

% --------------------------------------------------------------------------------------------------------------------------------------------------------------------------- %
\rhead{\footnotesize\rightmark}
\chapter{Commande robuste}

	Un retour d'état $K$ stabilisant le système et rejetant, au mieux, les perturbations (couple résistant $C_{charge}$) ayant été calculé pour le point de fonctionnement ($X_0$, $U_0$) considéré, il est maintenant nécessaire de vérifier la stabilité du système bouclé pour des points de fonctionnement différents. En effet, le point d'équilibre peut être en réalité légèrement différent ce celui calculé dans le chapitre 2. \\
	
	Nous utiliserons pour cela des méthodes de calcul \textit{LMI} (Linear Matrix Inequalities) (toolbox \texttt{lmi} de Matlab).


	\section{Calcul du retour d'état $K_{lmi}$ stabilisant}
	
		Nous allons tout d'abord recalculer un gain de retour d'état stabilisant le système (noté $K_{lmi}$). Cet exercice est bien entendu redondant par rapport à la partie précédente mais il permet d'introduire les \textit{LMI}. \\
		
		La théorie des \textit{LMI} que l'existence d'une matrice symétrique $P$ satisfaisant la théorie de Lyapunov est une condition nécessaire et suffisante de stabilité pouvant être décrite par l'équation : 
		
						\begin{equation}
				\begin{split}
			PA^T + AP & < 0 \\
			P & > 0 
							\end{split}
						\end{equation}

		
		La matrice dynamique $A$ d'un système bouclé avec un gain de retour d'état $u = Kx$ étant égale à $A_{bouclé} = (A - BK)$, on aura alors la \textit{LMI} suivante comme condition nécessaire et suffisante de stabilité : 
		
		
						\begin{equation}
				\begin{split} \label{eq:lmi_base}
			P(A+BK)^T + (A+BK)P & < 0 \\
			P & > 0 
					\end{split}
						\end{equation}
		
		Cette \textit{LMI} étant non-linéaire, il est nécessaire d'effectuer le changement de variable $K = LP^{-1}$ pour assurer sa linéarité.
		
		\begin{equation}
				\begin{split}
			PA^T + AP + L^TB + BL & < 0  \\
			P & > 0 
					\end{split}
						\end{equation}
		
		La matrice $K_{lmi}$ retournée par le script Matlab est alors telle que : 
		
		\begin{equation}
			K_{lmi} = [1.0042   -4.0059   -2.3667   -1.9401]
		\end{equation}
		
		Et permet d'assurer la stabilité du système en plaçant les pôles dans le demi-plan gauche du plan complexe. Cependant, comme aucune autre spécification sur le placement des pôles n'est donnée, le solveur \textit{LMI} se contente de trouver un seul gain qui stabilise le système. Autrement dit, la dernière itération correspond à l'itération à laquelle le solveur a trouvé pour la première fois un gain stabilisant. \\ 
		
		L'objectif est maintenant de spécifier des régions \textit{LMI} (à l'aide par exemple de la commande \texttt{lmireg})pour que les pôles en boucle fermée appartiennent à l'intersection de ces régions. Ces régions correspondent à : 
		
		\begin{itemize}
			\item Un demi-plan dont la partie réelle est inférieure à une valeur négative $x_0$ donnée, spécifiant alors le \textbf{temps de réponse du système}.
			\item Un demi-plan dont la partie réelle est supérieure à une valeur négative $x_1$ (telle que $x_1 < x_0$) donnée, pour \textbf{rester dans la bande passante} du système.
			\item Un secteur conique dont la pointe est située à l'origine du plan complexe, pour fixer l'amortissement et donc \textbf{limiter le dépassement}.
		\end{itemize}
			
	
	\section{Vérification de la stabilité du système}
	
	La stabilité du système étant prouvée autour du point d'équilibre ($X_0$, $U_0$) (avec les performances souhaitées), il est maintenant nécessaire de vérifier au moins la stabilité du système bouclé autour d'autres points de fonctionnement (les performances pouvant être dégradées). \\
	
	Nous allons maintenant utiliser une des propriétés des \textit{LMI} qui spécifie que rajouter d'une équation à la \textit{LMI} correspond à l'ajout d'une contrainte pour la solution finale. \\
	
	Nous allons donc conserver le gain stabilisant $K$ calculé dans le chapitre 4 et changer le point d'équilibre (c'est-à-dire la matrice $A_{lin}$). L'objectif est de vérifier si la \textit{LMI} précédente peut-être résolue pour tous les points d'équilibre. La nouvelle \textit{LMI} s'écrit alors (avec $n$, le nombre de points d'équilibre connus) : 
	
		\begin{equation}
				\begin{split}
			P(A_1-BK)^T + (A_1-BK)P & < 0 \\
			P(A_2-BK)^T + (A_2-BK)P & < 0 \\
			\cdots \\
			P(A_n-BK)^T + (A_n-BK)P & < 0 \\
			P & > 0 
				\end{split}
		\end{equation}
		
		Le calcul sous Matlab (en utilisant la toolbox \texttt{lmi}) consiste en l'ajout successif des contraintes à la \textit{LMI} de base (eq. \ref{eq:lmi_base}). Le solveur indique alors que la \textit{LMI} peut-être résolue (en 3 itérations) et fournie une matrice $P$ (de dimension (4,4)) vérifiant le système d'équations précédent. \\
		
		\textit{Remarque : Bien entendu, vérifier l'appartenance des pôles des systèmes bouclés considérés au demi-plan complexe gauche aurait suffit pour s'assurer de la bonne stabilisation du système. La technique présentée ici a cependant l'avantage d'être générique et moins fastidieuse.}
		
		
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
