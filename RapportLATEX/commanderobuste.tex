% !TEX encoding = IsoLatin
% --------------------------------------------------------------------------------------------------------------------------------------------------------------------------- %
%\begin{itemize}
%\item [-] \textbf{Création} : Demandée par un autre processus,  crée dans l'état prêt ou suspendu.
%\item [-] \textbf{Destruction} : peut être fait par le processus lui-même, un autre processus, le noyau. La destruction provoque une libération des ressources associées et un évènement.
%\item [-] \textbf{Blocage} : passage en mode bloqué en attente d'un évènement externe. Peut être demandé par le processus lui-même ou par le système.
%\item [-] \textbf{Déblocage} : passage en mode prêt après le mode bloqué lorsque l'événement attendu se produit.
%\item [-] \textbf{Activation} : passage en mode exécution d'un mode prêt.
%\end{itemize}

  
%\begin{Verbatim}[frame=single,fontsize=\scriptsize]
%\end{Verbatim}

%\begin{figure}[h]
%	\begin{center}
%		\includegraphics[width=14.5cm,height=9cm]{.\figures\diag_etat_threads.png}
%	\end{center}
%	\caption{Diagramme des différents états d'un thread avec les primitives}
%	\label{fig:diag_etat_threads}
%\end{figure}

%% Modele d'etat avec les matrices

%\begin{displaymath}
%\left\{ \begin{array}{l} \dot{x} \quad = \quad \left[ \begin{array}{cccc}
%0 & 1 & 0 & 1\\
%- \frac{K_s}{M_s} & - \frac{C_s}{M_s} & 0 & \frac{C_s}{M_s}\\
%0 & 0 & 0 & 1\\
%\frac{K_s}{M_u} & \frac{C_s}{M_u} & - \frac{K_t}{M_u} & - \frac{C_s}{M_u} - \frac{C_t}{M_u}
%
%\end{array}\right]  x \quad + \quad \left[ \begin{array}{cc}
%0 & 1.1972\\
%0 & - 0.0012\\
%0 & 0\\
%7.84 & - 4.05
%\end{array} \right] u\\ \\
%y \quad = \quad \left[ \begin{array}{cccc}
%1 & 0 & 0 & 0\\
%0 & \lambda & 0 & 0\\
%0 & 0 & \lambda & 0\\
%0 & 0 & 0 & \lambda\\
%0 & - \lambda & \lambda & 0
%\end{array} \right] x \quad + \quad \left[ \begin{array}{cc}
%0 & 0\\
%0 & 0\\
%0 & 0\\
%0 & 0\\
%0 & 0
%\end{array} \right] u \end{array}\right.
%\end{displaymath}\\

% --------------------------------------------------------------------------------------------------------------------------------------------------------------------------- %
\rhead{\footnotesize\rightmark}
\chapter{Commande robuste}

\textcolor{red}{Maffre}

	Un retour d'état $K$ stabilisant le système et rejetant, au mieux, les perturbations (couple résistant $C_{charge}$) ayant été calculé pour le point de fonctionnement ($X_0$, $U_0$) considéré, il est maintenant nécessaire de vérifier la stabilité du système bouclé pour des points de fonctionnement différents. En effet, le point d'équilibre peut être en réalité légèrement différent ce celui calculé dans le chapitre 2. \\
	
	Nous utiliserons pour cela des méthodes de calcul \textit{LMI} (Linear Matrix Inequalities) (toolbox \texttt{lmi} de Matlab).


	\section{Calcul du retour d'état $K_{lmi}$ stabilisant}
	
		Nous allons tout d'abord recalculer un gain de retour d'état stabilisant le système (noté $K_{lmi}$). Cet exercice est bien entendu redondant par rapport à la partie précédente mais il permet d'introduire les \textit{LMI}. \\
		
		La théorie des \textit{LMI} que l'existence d'une matrice symétrique $P$ satisfaisant la théorie de Lyapunov est une condition nécessaire et suffisante de stabilité pouvant être décrite par l'équation : 
		
		\begin{align}
			PA^T + AP & < 0 \\
			P & > 0 
		\end{align}
		
		La matrice dynamique $A$ d'un système bouclé avec un gain de retour d'état $u = -Kx$ étant égale à $A_{bouclé} = (A - BK)$, on aura alors la \textit{LMI} suivante comme condition nécessaire et suffisante de stabilité : 
		
		\begin{align}
			P(A-BK)^T + (A+BK)P & < 0 \\
			P & > 0 
		\end{align}
		
		Cette \textit{LMI} étant non-linéaire, il est nécessaire d'effectuer le changement de variable $K = LP^{-1}$ pour assurer sa linéarité.
		
		\begin{align}
			PA^T + AP + L^TB + BL & < 0  \\
			P & > 0 
		\end{align}
		
		
		
		
		
		
		
		
	
	
	
	\section{Vérification de la stabilité du système}
